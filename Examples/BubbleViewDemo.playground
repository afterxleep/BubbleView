// BubbleView Demo Playground

import SwiftUI
import PlaygroundSupport
#if canImport(BubbleView)
import BubbleView
#endif

#if !canImport(BubbleView)
// Local fallback so the playground runs out of the box without adding the package.
struct Bubble: InsettableShape {
    let arrowLength: CGFloat
    let arrowWidth: CGFloat
    let arrowPositionPercent: CGFloat
    let cornerRadius: CGFloat
    let bend: CGFloat
    let finSideCurve: CGFloat
    let finTipRadius: CGFloat
    let finTipRoundness: CGFloat

    func path(in rect: CGRect) -> Path {
        let radius = max(0, cornerRadius)
        guard rect.width >= 2 * radius, rect.height >= 2 * radius else {
            return Path(roundedRect: rect, cornerRadius: radius)
        }

        let (minX, minY) = (rect.minX, rect.minY)
        let (width, height) = (rect.width, rect.height)
        let (maxX, maxY) = (rect.maxX, rect.maxY)

        // Calculate Arrow Position on FLAT Edges
        let flatWidth = width - 2 * radius
        let flatHeight = height - 2 * radius
        let flatPerimeter = max(0.001, 2 * (flatWidth + flatHeight))

        let adjustedPercent = arrowPositionPercent.truncatingRemainder(dividingBy: 100.0)
        let effectivePercent = min(99.9, max(0.1, adjustedPercent)) / 100.0
        let targetFlatDistance = flatPerimeter * effectivePercent
        let flatEdgeSafeDistance = arrowWidth / 2 + 1.0

        var arrowEdge: Edge = .top
        var arrowCenterX: CGFloat = 0
        var arrowCenterY: CGFloat = 0

        // Determine Edge and Center Point ON THE FLAT SECTION
        if targetFlatDistance <= flatWidth {
            arrowEdge = .top
            var centerOnFlat = targetFlatDistance
            if flatWidth > 0 {
                centerOnFlat = max(flatEdgeSafeDistance, min(flatWidth - flatEdgeSafeDistance, centerOnFlat))
            }
            arrowCenterX = minX + radius + centerOnFlat
            arrowCenterY = minY
        } else if targetFlatDistance <= flatWidth + flatHeight {
            arrowEdge = .right
            var centerOnFlat = targetFlatDistance - flatWidth
            if flatHeight > 0 {
                centerOnFlat = max(flatEdgeSafeDistance, min(flatHeight - flatEdgeSafeDistance, centerOnFlat))
            }
            arrowCenterX = maxX
            arrowCenterY = minY + radius + centerOnFlat
        } else if targetFlatDistance <= 2 * flatWidth + flatHeight {
            arrowEdge = .bottom
            var centerOnFlat = targetFlatDistance - (flatWidth + flatHeight)
            if flatWidth > 0 {
                centerOnFlat = max(flatEdgeSafeDistance, min(flatWidth - flatEdgeSafeDistance, centerOnFlat))
            }
            arrowCenterX = maxX - radius - centerOnFlat
            arrowCenterY = maxY
        } else {
            arrowEdge = .left
            var centerOnFlat = targetFlatDistance - (flatWidth + flatHeight + flatWidth)
            if flatHeight > 0 {
                centerOnFlat = max(flatEdgeSafeDistance, min(flatHeight - flatEdgeSafeDistance, centerOnFlat))
            }
            arrowCenterX = minX
            arrowCenterY = maxY - radius - centerOnFlat
        }

        // Calculate Arrow Base Points (p1, p2)
        let halfArrowWidth = arrowWidth / 2
        var p1, p2: CGPoint
        switch arrowEdge {
            case .top:
                p1 = CGPoint(x: arrowCenterX - halfArrowWidth, y: arrowCenterY)
                p2 = CGPoint(x: arrowCenterX + halfArrowWidth, y: arrowCenterY)
            case .right:
                p1 = CGPoint(x: arrowCenterX, y: arrowCenterY - halfArrowWidth)
                p2 = CGPoint(x: arrowCenterX, y: arrowCenterY + halfArrowWidth)
            case .bottom:
                p1 = CGPoint(x: arrowCenterX + halfArrowWidth, y: arrowCenterY)
                p2 = CGPoint(x: arrowCenterX - halfArrowWidth, y: arrowCenterY)
            case .left:
                p1 = CGPoint(x: arrowCenterX, y: arrowCenterY + halfArrowWidth)
                p2 = CGPoint(x: arrowCenterX, y: arrowCenterY - halfArrowWidth)
        }

        let outwardNormal = Bubble.outwardNormal(for: arrowEdge)
        let tangent = Bubble.edgeTangent(for: arrowEdge)
        let bendOffset = bend * halfArrowWidth
        let tip = CGPoint(x: arrowCenterX + outwardNormal.x * arrowLength + tangent.x * bendOffset,
                          y: arrowCenterY + outwardNormal.y * arrowLength + tangent.y * bendOffset)
        let effectiveTipRadius = finTipRadius

        // Define Rounded Rectangle Corner Points & Arc Centers
        let pointTopLeft = CGPoint(x: minX + radius, y: minY)
        let pointTopRight = CGPoint(x: maxX - radius, y: minY)
        let pointRightBottom = CGPoint(x: maxX, y: maxY - radius)
        let pointBottomLeft = CGPoint(x: minX + radius, y: maxY)
        let pointLeftTop = CGPoint(x: minX, y: minY + radius)

        let centerTopLeft = CGPoint(x: minX + radius, y: minY + radius)
        let centerTopRight = CGPoint(x: maxX - radius, y: minY + radius)
        let centerBottomRight = CGPoint(x: maxX - radius, y: maxY - radius)
        let centerBottomLeft = CGPoint(x: minX + radius, y: maxY - radius)

        // Draw!
        var path = Path()
        path.move(to: pointTopLeft)

        if arrowEdge == .top { path.addLine(to: p1); Bubble.addFin(to: &path, from: p1, to: p2, tip: tip, tipRadius: effectiveTipRadius, tipRoundness: finTipRoundness, sideCurve: finSideCurve, bend: bend) }
        path.addLine(to: pointTopRight)
        if radius > 0 { path.addArc(center: centerTopRight, radius: radius, startAngle: .degrees(-90), endAngle: .degrees(0), clockwise: false) }

        if arrowEdge == .right { path.addLine(to: p1); Bubble.addFin(to: &path, from: p1, to: p2, tip: tip, tipRadius: effectiveTipRadius, tipRoundness: finTipRoundness, sideCurve: finSideCurve, bend: bend) }
        path.addLine(to: pointRightBottom)
        if radius > 0 { path.addArc(center: centerBottomRight, radius: radius, startAngle: .degrees(0), endAngle: .degrees(90), clockwise: false) }

        if arrowEdge == .bottom { path.addLine(to: p1); Bubble.addFin(to: &path, from: p1, to: p2, tip: tip, tipRadius: effectiveTipRadius, tipRoundness: finTipRoundness, sideCurve: finSideCurve, bend: bend) }
        path.addLine(to: pointBottomLeft)
        if radius > 0 { path.addArc(center: centerBottomLeft, radius: radius, startAngle: .degrees(90), endAngle: .degrees(180), clockwise: false) }

        if arrowEdge == .left { path.addLine(to: p1); Bubble.addFin(to: &path, from: p1, to: p2, tip: tip, tipRadius: effectiveTipRadius, tipRoundness: finTipRoundness, sideCurve: finSideCurve, bend: bend) }
        path.addLine(to: pointLeftTop)
        if radius > 0 { path.addArc(center: centerTopLeft, radius: radius, startAngle: .degrees(180), endAngle: .degrees(270), clockwise: false) }

        path.closeSubpath()
        return path
    }

    func inset(by amount: CGFloat) -> some InsettableShape {
        return self
    }

    enum Edge { case top, right, bottom, left }

    private static func outwardNormal(for edge: Edge) -> CGPoint {
        switch edge {
            case .top: return CGPoint(x: 0, y: -1)
            case .right: return CGPoint(x: 1, y: 0)
            case .bottom: return CGPoint(x: 0, y: 1)
            case .left: return CGPoint(x: -1, y: 0)
        }
    }

    private static func edgeTangent(for edge: Edge) -> CGPoint {
        switch edge {
            case .top: return CGPoint(x: 1, y: 0)
            case .right: return CGPoint(x: 0, y: 1)
            case .bottom: return CGPoint(x: -1, y: 0)
            case .left: return CGPoint(x: 0, y: -1)
        }
    }


    private static func addFin(
        to path: inout Path,
        from p1: CGPoint,
        to p2: CGPoint,
        tip: CGPoint,
        tipRadius: CGFloat,
        tipRoundness: CGFloat,
        sideCurve: CGFloat,
        bend: CGFloat
    ) {
        let sideLength1 = distance(p1, tip)
        let sideLength2 = distance(p2, tip)
        guard sideLength1 > 0.001, sideLength2 > 0.001 else {
            path.addLine(to: tip)
            path.addLine(to: p2)
            return
        }

        let maxTipCut = max(0, min(sideLength1, sideLength2) - 0.001)
        let roundness = max(0, min(1, tipRoundness))
        let tipCut = min(maxTipCut * roundness, max(0, tipRadius))
        let curveStrength = max(0, min(1, sideCurve)) * min(sideLength1, sideLength2) * min(1, abs(bend)) * 0.35
        let baseMid = CGPoint(x: (p1.x + p2.x) * 0.5, y: (p1.y + p2.y) * 0.5)
        let baseDX = p2.x - p1.x
        let baseDY = p2.y - p1.y
        let baseLen = sqrt(baseDX * baseDX + baseDY * baseDY)
        let tanX = baseLen > 0.001 ? baseDX / baseLen : 0
        let tanY = baseLen > 0.001 ? baseDY / baseLen : 0
        let bendDir = (tip.x - baseMid.x) * tanX + (tip.y - baseMid.y) * tanY
        let s1 = (p1.x - baseMid.x) * tanX + (p1.y - baseMid.y) * tanY
        let outerIsFirst: Bool
        if abs(bendDir) < 0.001 {
            outerIsFirst = sideLength1 >= sideLength2
        } else {
            outerIsFirst = s1 * bendDir > 0
        }

        let interior1 = interiorNormal(from: p1, to: tip, interiorPoint: p2)
        let interior2 = interiorNormal(from: tip, to: p2, interiorPoint: p1)
        let normal1 = outerIsFirst ? interior1 : CGPoint(x: -interior1.x, y: -interior1.y)
        let normal2 = outerIsFirst ? CGPoint(x: -interior2.x, y: -interior2.y) : interior2

        if tipCut <= 0 {
            if curveStrength > 0.001 {
                let c1 = controlPoint(from: p1, to: tip, normal: normal1, curveAmount: curveStrength)
                path.addQuadCurve(to: tip, control: c1)
                let c2 = controlPoint(from: tip, to: p2, normal: normal2, curveAmount: curveStrength)
                path.addQuadCurve(to: p2, control: c2)
            } else {
                path.addLine(to: tip)
                path.addLine(to: p2)
            }
            return
        }

        let t1 = point(from: tip, toward: p1, distance: tipCut)
        let t2 = point(from: tip, toward: p2, distance: tipCut)

        if curveStrength > 0.001 {
            let c1 = controlPoint(from: p1, to: t1, normal: normal1, curveAmount: curveStrength)
            path.addQuadCurve(to: t1, control: c1)
        } else {
            path.addLine(to: t1)
        }

        let tipSpan = distance(t1, t2)
        if tipSpan > 0.001 {
            let u1 = unitVector(from: t1, toward: tip)
            let u2 = unitVector(from: t2, toward: tip)
            let k = min(tipSpan * 0.6, tipCut * 1.5)
            let cTip1 = CGPoint(x: t1.x + u1.x * k, y: t1.y + u1.y * k)
            let cTip2 = CGPoint(x: t2.x + u2.x * k, y: t2.y + u2.y * k)
            path.addCurve(to: t2, control1: cTip1, control2: cTip2)
        } else {
            path.addLine(to: t2)
        }

        if curveStrength > 0.001 {
            let c2 = controlPoint(from: t2, to: p2, normal: normal2, curveAmount: curveStrength)
            path.addQuadCurve(to: p2, control: c2)
        } else {
            path.addLine(to: p2)
        }
    }

    private static func distance(_ p1: CGPoint, _ p2: CGPoint) -> CGFloat {
        let dx = p2.x - p1.x
        let dy = p2.y - p1.y
        return sqrt(dx * dx + dy * dy)
    }

    private static func point(from origin: CGPoint, toward target: CGPoint, distance: CGFloat) -> CGPoint {
        let dx = target.x - origin.x
        let dy = target.y - origin.y
        let length = sqrt(dx * dx + dy * dy)
        guard length > 0.001 else { return origin }
        let ux = dx / length
        let uy = dy / length
        return CGPoint(x: origin.x + ux * distance, y: origin.y + uy * distance)
    }

    private static func unitVector(from origin: CGPoint, toward target: CGPoint) -> CGPoint {
        let dx = target.x - origin.x
        let dy = target.y - origin.y
        let length = sqrt(dx * dx + dy * dy)
        guard length > 0.001 else { return .zero }
        return CGPoint(x: dx / length, y: dy / length)
    }

    private static func interiorNormal(from start: CGPoint, to end: CGPoint, interiorPoint: CGPoint) -> CGPoint {
        let dx = end.x - start.x
        let dy = end.y - start.y
        let length = sqrt(dx * dx + dy * dy)
        guard length > 0.001 else { return .zero }
        let leftX = -dy / length
        let leftY = dx / length
        let cross = dx * (interiorPoint.y - start.y) - dy * (interiorPoint.x - start.x)
        let sign: CGFloat = cross >= 0 ? 1 : -1
        return CGPoint(x: leftX * sign, y: leftY * sign)
    }

    private static func controlPoint(from start: CGPoint, to end: CGPoint, normal: CGPoint, curveAmount: CGFloat) -> CGPoint {
        let mid = CGPoint(x: (start.x + end.x) * 0.5, y: (start.y + end.y) * 0.5)
        return CGPoint(x: mid.x + normal.x * curveAmount,
                       y: mid.y + normal.y * curveAmount)
    }

}

struct BubbleView<Content: View>: View {
    let content: Content

    let arrowLength: CGFloat
    let arrowWidth: CGFloat
    let arrowPositionPercent: CGFloat
    let cornerRadius: CGFloat
    let bend: CGFloat
    let finSideCurve: CGFloat
    let finTipRadius: CGFloat
    let finTipRoundness: CGFloat
    let fillColor: Color
    let borderColor: Color
    let borderWidth: CGFloat
    let paddingAmount: CGFloat

    private var bubbleShape: Bubble {
        Bubble(arrowLength: arrowLength,
               arrowWidth: arrowWidth,
               arrowPositionPercent: arrowPositionPercent,
               cornerRadius: cornerRadius,
               bend: bend,
               finSideCurve: finSideCurve,
               finTipRadius: finTipRadius,
               finTipRoundness: finTipRoundness)
    }

    var body: some View {
        content
            .padding(paddingAmount)
            .background(
                bubbleShape.fill(fillColor)
            )
            .overlay(
                bubbleShape.strokeBorder(borderColor, lineWidth: borderWidth)
            )
            .padding(.top, arrowEdge == .top ? finDepth : 0)
            .padding(.bottom, arrowEdge == .bottom ? finDepth : 0)
            .padding(.leading, arrowEdge == .left ? finDepth : 0)
            .padding(.trailing, arrowEdge == .right ? finDepth : 0)
    }

    private var arrowEdge: Bubble.Edge {
        let radius = max(0, cornerRadius)
        let estWidth = max(0.1, 100 - 2 * radius)
        let estHeight = max(0.1, 50 - 2 * radius)
        let flatWidth = estWidth - 2 * radius
        let flatHeight = estHeight - 2 * radius
        let flatPerimeter = max(0.001, 2 * (flatWidth + flatHeight))

        let adjustedPercent = arrowPositionPercent.truncatingRemainder(dividingBy: 100.0)
        let effectivePercent = min(99.9, max(0.1, adjustedPercent)) / 100.0
        let targetFlatDistance = flatPerimeter * effectivePercent

        if targetFlatDistance <= flatWidth { return .top }
        else if targetFlatDistance <= flatWidth + flatHeight { return .right }
        else if targetFlatDistance <= 2 * flatWidth + flatHeight { return .bottom }
        else { return .left }
    }

    private var finDepth: CGFloat {
        max(0, arrowLength)
    }

    init(
        arrowLength: CGFloat = 15,
        arrowWidth: CGFloat = 30,
        arrowPositionPercent: CGFloat = 10,
        cornerRadius: CGFloat = 10,
        bend: CGFloat = 0,
        finSideCurve: CGFloat = 0,
        finTipRadius: CGFloat = .greatestFiniteMagnitude,
        finTipRoundness: CGFloat = 0,
        fillColor: Color = .blue,
        borderColor: Color = .clear,
        borderWidth: CGFloat = 0,
        paddingAmount: CGFloat = 10,
        @ViewBuilder content: () -> Content
    ) {
        self.arrowLength = arrowLength
        self.arrowWidth = arrowWidth
        self.arrowPositionPercent = arrowPositionPercent
        self.cornerRadius = cornerRadius
        self.bend = bend
        self.finSideCurve = finSideCurve
        self.finTipRadius = finTipRadius
        self.finTipRoundness = finTipRoundness
        self.fillColor = fillColor
        self.borderColor = borderColor
        self.borderWidth = borderWidth
        self.paddingAmount = paddingAmount
        self.content = content()
    }
}
#endif

struct PlaygroundContentView: View {
    @State private var arrowLength: Double = 18
    @State private var arrowWidth: Double = 28
    @State private var arrowPositionPercent: Double = 12
    @State private var cornerRadius: Double = 12
    @State private var bend: Double = 0.35
    @State private var finSideCurve: Double = 0.6
    @State private var finTipRoundness: Double = 0.6

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 30) {
                Text("BubbleView Examples").font(.largeTitle).padding(.bottom)

                // Interactive: Shark fin controls
                VStack(alignment: .leading, spacing: 16) {
                    Text("Shark Fin Playground").font(.title2)
                    let tipRadius: CGFloat = .greatestFiniteMagnitude
                    BubbleView(
                        arrowLength: CGFloat(arrowLength),
                        arrowWidth: CGFloat(arrowWidth),
                        arrowPositionPercent: CGFloat(arrowPositionPercent),
                        cornerRadius: CGFloat(cornerRadius),
                        bend: CGFloat(bend),
                        finSideCurve: CGFloat(finSideCurve),
                        finTipRadius: tipRadius,
                        finTipRoundness: CGFloat(finTipRoundness),
                        fillColor: Color(red: 0.12, green: 0.55, blue: 0.62),
                        borderColor: .black.opacity(0.2),
                        borderWidth: 1
                    ) {
                        HStack(spacing: 10) {
                            Image(systemName: "wave.3.right")
                                .foregroundColor(.white)
                                .font(.title3)
                            VStack(alignment: .leading, spacing: 2) {
                                Text("Shark Fin")
                                    .font(.headline)
                                    .foregroundColor(.white)
                                Text("Dial the shape below")
                                    .font(.caption)
                                    .foregroundColor(.white.opacity(0.85))
                            }
                        }
                        .padding(.vertical, 2)
                    }
                    .frame(width: 280, alignment: .leading)

                    VStack(alignment: .leading, spacing: 10) {
                        sliderRow(title: "Arrow Length", value: $arrowLength, range: 4...60)
                        sliderRow(title: "Arrow Width", value: $arrowWidth, range: 8...80)
                        sliderRow(title: "Arrow Position %", value: $arrowPositionPercent, range: 0.1...99.9)
                        sliderRow(title: "Corner Radius", value: $cornerRadius, range: 0...30)
                        sliderRow(title: "Bend", value: $bend, range: -10...10)
                        sliderRow(title: "Side Curve", value: $finSideCurve, range: 0...1)
                        sliderRow(title: "Tip Roundness", value: $finTipRoundness, range: 0...1)
                    }
                }

            }
            .padding()
        }
        .frame(width: 400, height: 800) // Set frame for playground live view
    }
}

private func sliderRow(title: String, value: Binding<Double>, range: ClosedRange<Double>) -> some View {
    VStack(alignment: .leading, spacing: 4) {
        HStack {
            Text(title)
            Spacer()
            Text(String(format: "%.1f", value.wrappedValue))
                .foregroundColor(.secondary)
        }
        Slider(value: value, in: range)
    }
}

// Set the live view for the playground
PlaygroundPage.current.setLiveView(PlaygroundContentView()) 
